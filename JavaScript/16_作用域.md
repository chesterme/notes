## 编译

1. 分词/词法分析：

这个过程将由字符组成的字符串分解成有意义的代码块，这些代码块被成为词法单元。

> 分词（tokenizing）和词法分析（Lexing）之间的区别是非常微妙、晦涩的，主要差异在于词法单元的识别是通过有状态还是无状态的方式进行的。简单来说，如果词法单元生成器在判断a 是一个独立的词法单元还是其他词法单元的一部分时，调用的是有状态的解析规则，那么这个过程就被称为词法分析。

2. 解析/语法分析

将词法单元流（数组）转换成一个由元素逐级嵌套所组成的代表了程序语法结构的树（抽象语法树）

var a = 2; 的抽象语法树中可能会有一个叫作`VariableDeclaration `的顶级节点，接下来是一个叫作Identifier（它的值是a）的子节点，以及一个叫作`AssignmentExpression`的子节点。`AssignmentExpression `节点有一个叫作`NumericLiteral`（它的值是2）的子节点。

3. 代码生成

将抽象语法树转换成可执行代码



## 执行环境

1. 它定义了变量或函数有权访问的其他数据，决定了它们各自的行为。
2. 每个执行环境都有一个与之关联的变量对象，环境中所有变量和函数都保存在这个对象中
3. 在web浏览器中，window对象是全局执行环境，因此所有全局变量和函数都是作为window对象的属性和方法创建的。
4. 某个执行环境中的所有代码被执行完毕后，该环境被销毁，保存在其中的所有变量和函数定义也随之销毁
5. 每个函数都有自己的执行环境。当执行流进入一个函数时，函数的环境就会被推入一个环境栈中。而在函数执行之后，栈将其环境弹出，把控制权返回给之前的执行环境。
6. 当代码在一个环境中执行时，会创建变量对象的一个作用域链（scope chain）。

## 什么是作用域链

1. 保证对执行环境有权访问的所有变量和函数的有序访问。
2. 作用域链的前端，始终都是当前执行的代码所在环境的变量对象。如果这个环境是函数，则将其活动对象（activation object）作为变量对象。活动对象在最开始时只包含一个变量，即arguments 对象（这个对象在全局环境中是不存在的）。作用域链中的下一个变量对象来自包含（外部）环境，而再下一个变量对象则来自下一个包含环境。这样，一直延续到全局执行境；全局执行环境的变量对象始终都是作用域链中的最后一个对象。
3. 标识符解析是沿着作用域链一级一级地搜索标识符的过程。搜索过程始终从作用域链的前端开始，然后逐级地向后回溯，直至找到标识符为止（如果找不到标识符，通常会导致错误发生）。
4. 内部环境可以通过作用域链访问所有的外部环境，但外部环境不能访问内部环境中的任何变量和函数。这些环境之间的联系是线性、有次序的。
5. 每个环境都可以向上搜索作用域链，以查询变量和函数名；但任何环境都不能通过向下搜索作用域链而进入另一个执行环境。

## 延长作用域链

具体来说，就是当执行流进入下列任何一个语句时，作用域链就会得到加长：

1. try-catch语句中的catch
2. with语句

这两个语句都会在作用域链的前端添加一个变量对象。对with 语句来说，会将指定的对象添加到作用域链中。对catch 语句来说，会创建一个新的变量对象，其中包含的是被抛出的错误对象的声明。

## 没有块级作用域

1. JavaScript中没有块级作用域，即

```javascript
if(true){
	var color = "blue";
}
alert(color); // "blue"
```

在这里，if语句中的变量声明会被添加到当前的执行环境中（这里是全局执行环境window对象上）

```javascript
for(var i = 0; i < 10; i++){
	doSomething(i);
}
alert(i); // 10
```

同理，由于不存在块级作用域，所以`var i = 0;`所以变量i被添加到当前执行环境中（即全局执行环境window对象上）

2. 如何在局部环境中声明变量对象？

使用var 声明的变量会自动被添加到最接近的环境中。在函数内部，最接近的环境就是函数的局部环境；在with 语句中，最接近的环境是函数环境。如果初始化变量时没有使用var 声明，该变量会自动被添加到全局环境。

## 浏览器如何确定某个标识符表示什么？

1. 当在某个环境中为了读取或写入而引用一个标识符时，必须通过搜索来确定该标识符实际代表什么。
2. 搜索过程从作用域链的前端开始，向上逐级查询与给定名字匹配的标识符。
3. 如果在局部环境中找到了该标识符，搜索过程停止，变量就绪。如果在局部环境中没有找到该变量名，则继续沿作用域链向上
   搜索。搜索过程将一直追溯到全局环境的变量对象。
4. 如果在全局环境中也没有找到这个标识符，则意味着该变量尚未声明。

## 垃圾收集

1. JavaScript 具有自动垃圾收集机制，也就是说，执行环境会负责管理代码执行过程中使用的内存。
2. 找出那些不再继续使用的变量，然后释放其占用的内存。为此，垃圾收集器会按照固定的时间间隔（或代码执行中预定的收集时间），周期性地执行这一操作。

### 函数中局部变量的正常生命周期

1. 局部变量只在函数执行的过程中存在。而在这个过程中，会为局部变量在栈（或堆）内存上分配相应的空间，以便存储它们的值。然后在函数中使用这些变量，直至函数执行结束。
2. 此时，局部变量就没有存在的必要了，因此可以释放它们的内存以供将来使用。
3. 垃圾收集器必须跟踪哪个变量有用哪个变量没用，对于不再有用的变量打上标记，以备将来收回其占用的内存。

### 标记清除

1. 当变量进入环境（例如，在函数中声明一个变量）时，就将这个变量标记为“进入环境”。从逻辑上讲，永远不能释放进入环境的变量所占用的内存，因为只要执行流进入相应的环境，就可能会用到它们。
2. 当变量离开环境时，则将其标记为“离开环境”。
3. 垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记
4. 然后，它会去掉环境中的变量以及被环境中的变量引用的变量的标记。而在此之后再被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了
5. 最后，垃圾收集器完成内存清除工作，销毁那些带标记的值并回收它们所占用的内存空间。

### 引用计数

1. 当声明了一个变量并将一个引用类型值赋给该变量时，则这个值的引用次数就是1。如果同一个值又被赋给另一个变量，则该值的引用次数加1。
2. 如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数减1。当这个值的引用次数变成0 时，则说明没有办法再访问这个值了，因而就可以将其占用的内存空间回收回来。
3. 当垃圾收集器下次再运行时，它就会释放那些引用次数为零的值所占用的内存。

### 引用计数存在的问题--循环引用

循环引用指的是对象A 中包含一个指向对象B 的指针，而对象B 中也包含一个指向对象A 的引用。

```javaScript
function problem(){
	var objectA = new Object();
	var objectB = new Object();
	objectA.someOtherObject = objectB;
	objectB.someOtherObject = objectA;
}
```

这里，`objectA`和`objectB`通过各自的属性相互引用，即这两个对象的引用次数都是2。

在采用标记清除策略的实现中，由于函数执行之后，这两个对象都离开了作用域，因此这种相互引用不是个问题。

但在采用引用计数策略的实现中，当函数执行完毕后，`objectA` 和`objectB `还将继续存在，因为它们的引用次数永远不会是0。假如这个函数被重复多次调用，就会导致大量内存得不到回收。

### 管理内存

1. 分配给浏览器的可使用内存通常比较小，目的是防止运行JavaScript的网页耗尽全部系统内存而导致系统崩溃。
2. 优化内存占用的最佳方式，就是为执行中的代码只保留必须的数据。一旦数据不再使用，最好通过将其值设置为null来释放其引用——即解除引用。

## 理解作用域

### 引擎

负责整个JavaScript程序的编译和执行过程

### 编译器

负责语法分析及代码分析

### 作用域

负责收集并维护所有声明的标识符（变量）组成的一系列查询，确定当前执行代码对这些标识符的访问权限

### 三者之间的联系

```javascript
var a = 2;
```

对于这条赋值语句，引擎认为这里有两个完全不同的声明，一个由编译器在编译时处理，另一个则由引擎在运行时处理。

1. 编译器首先会将这段程序分解成词法单元，然后将词法单元解析成一个树结构。
2. 遇到`var a`，编译器会查找作用域链，是否已经在同一个作用域的集合（某个环境对象）中存在一个名为`a`的变量。如果是，编译器会忽略该声明，继续进行编译；否则它会要求作用域在当前作用域的集合中声明一个新的变量，并命名为a；
3. 编译器会为引擎生成运行时所需要的代码，它们被用来处理`a =  2`这个赋值操作。引擎运行时会首先询问作用域，在当前的作用域集合中是否存在一个叫作a 的变量。如果是，引擎就会使用这个变量；如果否，引擎会继续查找该变量。
4. 如果引擎最终找到了a 变量，就会将2 赋值给它。否则引擎就会举手示意并抛出一个异常！

小结：

变量的赋值操作会执行两个动作，首先编译器会在当前作用域中声明一个变量（如果之前没有声明过），然后在运行时引擎会在作用域中查找该变量，如果能够找到就会对它赋值。