---
typora-root-url: ..
---

## 布局分类

+ 响应式，使用百分数定义宽度，允许页面随显示环境的改变进行放大或缩小 
+ 固定式， 整个页面和每一栏都有基于像素的宽度 

## 盒子模型

+ 内容
+ 内边距
+ 边框
+ 外边距

### 宽度

+ css中的宽度是指内容的宽度
+ 元素在浏览器中显示的宽度则是**内容宽度+左右内边距+左右边框**
+ 高度也类似

### 浏览器计算宽度

+ 默认计算方式，css中的宽度和元素显示的宽度不一致
+ 设置css中的宽度为元素显示的宽度，**box-sizing: border-box;**，即内容宽度不用显示指出，**width****属性中的值就是**内容宽度+左右内边距+左右边框**

## 元素的显示类型

### 表现为块级元素

```css
div {
	display: block;
}
```

### 表现为行内元素

```css
div{
	display: inline;
}
```

### 让元素在一行内显示，但可以调整高度

```css
div{
	display: inline-block;
}
```

+ **li,ol**元素默认的显示行为是**display: list-item;**，从上往下显示，可以通过**display: inline;**改变其显示方式

### 控制元素的可见性

```css
div {
  	visibility: hidden;
    visibility: visible;
}
```

## 元素的宽度和高度

### 块级元素宽的的auto值

+ 由父元素的宽度-元素的内边距-边框-外边距

### 最小宽度和最小高度

+ **min-with**
+ **min-height**

## 浮动

### 用来做什么

1. 文字，图片的排版问题
2. 创建分栏

### 如何浮动

+ 设置浮动元素的宽度大小
+ 设置浮动方向
+ 浮动结束后清除浮动

### 浮动的表现

#### 实现文字围绕图片

**在浮动一张图片或其他元素时，浏览器会将它往上方移动，直到它父级元素的内边界为止。其后的元素不再认为浮动元素是在它的前面，因此它会占据其父元素的左上角的位置。但是它的内容会绕开浮动元素的内容**。例如：

![1580376557451](./css/images/1580376557451.png)

#### 创建分栏

![1580435815284](./css/images/1580435815284.png)

#### 浮动的一些细节

1. 浮动元素的包含块是其最近的外部容器
2. 浮动元素会生成一个块级框，即表现为**display: block;**，即可以调整宽高
3. 浮动元素的左右外边界不能超出其外部容器的左右内边界，即外部容器能放下浮动元素

![1580359932108](./css/images/1580359932108.png)

4. 浮动元素的下方元素(文字和图片)为围绕该元素显示

未浮动的结构：

![1580360607389](./css/images/1580360607389.png)

浮动之后的结构：

![1580360724286](./css/images/1580360724286.png)

表现为：将浮动元素从当前页面流中拿出来，后面的元素往上显示，然后将浮动元素插入到原来的位置，但其后的段落会表现为得到额外的左内/外边距（实际上段落的参数在浏览器中没有发生变化），而接着的块级元素的一部分被浮动元素覆盖，它与段落的显示不同。

当使用**span元素**替代**p元素**后，表现为：

![1580361807435](./css/images/1580361807435.png)



当去掉段落元素，使用一个大小不同块级元素，效果更为明显：

![1580361295636](./css/images/1580361295636.png)

使用大小相同的块级元素，

未浮动前：

![1580361588767](./css/images/1580361588767.png)

浮动后：

![1580361619005](./css/images/1580361619005.png)

当其后元素是**img元素**时，表现为：

![1580362503326](./css/images/1580362503326.png)

### 浮动带来的问题

**浮动元素脱离了文档流，其父元素不知道它的存在，因此父元素的内容大小不会包括它。**

1. 如果浮动元素的大小超出外部容器的大小，浮动元素会溢出

![1580376459946](./css/images/1580376459946.png)如果外部容器的能容下浮动元素，则不会溢出

![1580376557451](./css/images/1580376557451.png)

此时可以通过以下方式解决溢出问题：

1. clearfix方式
2. overflow方式



### 解决浮动问题的方式

#### clearfix方式

在父元素内容的最后添加一个非浮动的子元素，然后清除该子元素。父级元素一定会包含非浮动元素，而清除浮动，会让这个子元素位于浮动元素的下方，因此父级元素一定会包含浮动元素。

```css
// 将其应用到浮动元素的容器中
.clearfix::after{
	clear: both;
    content: '';
    display: block;
}
```

#### overflow方式

1. 强制让父元素围绕浮动元素
2. 这种做法是用来防止父级元素被超大内容撑大，应用该样式之后，父级元素依然保持原有的宽度，而超大的子内容则会容器剪切掉。
3. 它能可靠地迫使父元素包含其浮动元素

```css
.container{
    overflow: hidden;  // 可能会将内容折断
    overflow: auto; // 可能会产生一个滚动条
}
```

#### 让父元素也浮动起来

```css
.outer{
	float: left;
}
.inner{
    float: left;
}
```

## 定位

#### 静态定位

浏览器默认使用的方式，每个元素的显示顺序为文档流中的顺序

#### 绝对定位

默认情况下，参照物是整个页面，即**body元素**

```css
div{
	position: absolute;
    top: 40px;
    right: 0;
}
```

#### 相对定位

##### 默认情况

在不另外设置参照物的情况下，是相对于自己原来的位置来定位

```css
p.test{
    position: relative;
    top: 1rem;
    left: 1rem;
}
```

![1580437911908](./css/images/1580437911908.png)

除了该元素相对于原来的位置移动一下以外，其他元素的位置不发生任何变化

##### 已经设置参照物的情况下

任何父级元素都可以作为该元素的参照物

```css
.container{
    position: relative;
}
p.test{
    position: absolute;
    top: 1rem;
    left: 1rem;
}
```

![1580438202021](./css/images/1580438202021.png)

此时定位元素是相对于它的父级元素来进行定位，其他元素的位置也不发生变化

#### 固定定位

它相对于浏览器窗口进行定位，因此它不会随着页面的滚动而发生变化，效果为该元素固定在浏览器窗口的某个位置。

```css
.header{
    position: fixed;
    top: 0;
    left； 0；
}
```

![1580440005626](./css/images/1580440005626.png)

#### 处理重叠元素

使用**z-index**属性，数值越大，显示越前。定位的盒子按照 z-index 由高到低的次序进行叠放。 

## 显示属性

#### 让元素具有块级属性的特性

```css
.test{
	display: block;
}
```

#### 让元素具有行内属性的特性

```css
.test{
	display: inline;
}
```

#### 让元素同时具有块级和行内属性的特性

```css
.test{
	display: inline-block;
}
```

#### 让元素不在页面中显示

```css
.test{
	display: none;
}
```

#### 让元素可显示

```css
.test{
  	display: visible;
}
```

