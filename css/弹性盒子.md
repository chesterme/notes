## 已有的用于布局的技术

### 行内块

使用行内块（`inline-block`）来布局的最大问题，就是它会在HTML元素间渲染空白

![1563434666220](images\1563434666220.png)
```css
		*{
            padding: 0;
            margin: 0;
            box-sizing: border-box;
        }
        .main{
            background-color: aqua;
        }
        .left{
            background-color: aliceblue;
            width: 33%;
            padding: 1rem;
        }
        .center{
            background-color: antiquewhite;
            width: 33%;
            padding: 1rem;
        }
        .right{
            background-color: aquamarine;
            width: 33%;
            padding: 1rem;
        }
        .main div{
            display: inline-block;
        }
```
#### 消除元素之间的空白

产生空白的原因是由换行或者回车导致的，理论上只要把标签写成一行或者标签直接没有空格，就不会出现间隙。

1. 移除标签间的空格

```html
	<div class="main">
        <div class="left">left</div><!--
        --><div class="center">center</div><!--
        --><div class="right">right</div>
    </div>
```

![1563435102964](images\1563435102964.png)

2. 取消标签闭合

```html
	<div class="demo">
        <span>我是一个span
        <span>我是一个span
        <span>我是一个span
        <span>我是一个span</span>
    </div>
```

```css
	   .demo{
            background-color: aqua;
        }
        .demo span{
            display: inline-block;
            font-size: 14px;
            background-color: aliceblue;
            padding: 1rem 0;
        }
```

![1563435589680](D:\notes\css\images\1563435589680.png)

3. 使用`font-size: 0;`

在父容器上使用`font-size:0;`可以消除间隙

![1563435761332](D:\notes\css\images\1563435761332.png)

```css
		.demo{
            background-color: aqua;
            font-size: 0;
        }
        .demo span{
            display: inline-block;
            font-size: 14px;
            background-color: aliceblue;
            padding: 1rem 0;
        }
```

#### 行内块元素垂直居中

### 浮动

### 表格

## 弹性盒子

### 完美垂直居中文本

```html
<div class="CenterMe">
	Hello, I'm centered with Flexbox!
</div>
```

```css
.CenterMe {
    background-color: indigo;
    color: #ebebeb;
    font-family: 'Oswald', sans-serif;
    font-size: 2rem;
    text-transform: uppercase;
    height: 200px;
    display: flex;
    align-items: center;
    justify-content: center;
}
```

> display: flex：这是`Flexbox`的根本所在。这里就是把当前元素设置为一个`Flexbox`（而不是block或`inline-block`之类的）。
>
> align-items：这是要在`Flexbox`中沿交叉轴对齐项目（在这个例子中垂直居中文本）。
>
> justify-content：在这里设置内容沿主轴居中

### 使用flex布局设置导航栏

#### 正序排列

```html
<div class="MenuWrap">
    <a href="#" class="ListItem">Home</a>
    <a href="#" class="ListItem">About Us</a>
    <a href="#" class="ListItem">Products</a>
    <a href="#" class="ListItem">Policy</a>
    <a href="#" class="LastItem">Contact Us</a>
</div>
```

```css
.MenuWrap {
    background-color: indigo;
    font-family: 'Oswald', sans-serif;
    font-size: 1rem;
    min-height: 2.75rem;
    display: flex;
    align-items: center;
    padding: 0 1rem;
}
.ListItem,
.LastItem {
    color: #ebebeb;
    text-decoration: none;
}
.ListItem {
	margin-right: 1rem;
}
.LastItem {
	margin-left: auto;
}
```

![1563441033604](images\1563441033604.png)

#### 反序排列

给包含元素的`CSS`加一行`flex-direction: row-reverse`，把最后一项的`marginleft:auto`改成`margin-right: auto`：

```css
.MenuWrap {
    background-color: indigo;
    font-family: 'Oswald', sans-serif;
    font-size: 1rem;
    min-height: 2.75rem;
    display: flex;
    flex-direction: row-reverse;
    align-items: center;
    padding: 0 1rem;
}
.ListItem,
.LastItem {
color: #ebebeb;
	text-decoration: none;
}
.ListItem {
	margin-right: 1rem;
}
.LastItem {
	margin-right: auto;
}
```

![1563441224278](images\1563441224278.png)

#### 垂直排列

在包含元素中使用`flex-direction:column;`，再把自动外边距属性删掉：

```css
.MenuWrap {
    background-color: indigo;
    font-family: 'Oswald', sans-serif;
    font-size: 1rem;
    min-height: 2.75rem;
    display: flex;
    flex-direction: column;
        align-items: center;
    padding: 0 1rem;
}
.ListItem,
.LastItem {
    color: #ebebeb;
    text-decoration: none;
}
```

![1563441384700](images\1563441384700.png)

#### 垂直反序排列

只要改成`flex-direction: column-reverse;`就行了

### 行内伸缩

`Flexbox`与有与`inline-block`和`inline-table`对应的`inline-flex`变体。得益于它的居中能力，通过行内伸缩模型可以轻松实现一些搞怪的效果

```css
.InlineFlex {
    display: inline-flex;
    align-items: center;
    height: 120px;
    padding: 0 4px;
    background-color: indigo;
    text-decoration: none;
    border-radius: 3px;
    color: #ddd;
}
```

```html
<p class="demo">Here is a sentence with a <a href="http://www.w3.org/TR/cssflexbox-
        1/#flex-containers" class="InlineFlex">inline-flex link</a>.</p>
```

**如果将某元素无端地设置为`display: inline-flex`（比如包含该元素的元素没有被设置为`display: flex`），那么这个元素就会像`inline-block`和`inline-table`一样保留元素间的空白。**

![1563442046245](images\1563442046245.png)

**如果这个元素处于一个`Flexbox`中，空白就会消失，就跟table中的table-cell一样。**

```css
.demo{
	display: flex;
}
```

![1563442118381](images\1563442118381.png)

## `flexbox`的对齐

关于`Flexbox`的对齐，最重要的是理解坐标轴。有两个轴，“主轴”和“交叉轴”。这两个轴代表什么取决于`Flexbox`排列的方向。

比如**，如果将`Flexbox`的方向设置为row，则主轴就是横轴，而交叉轴就是纵轴。**
反之，**如果`Flexbox`的方向是column，则主轴就是纵轴，而交叉轴为横轴。**

![1563442393594](images\1563442393594.png)

#### align-items

`align-items`在交叉轴上定位元素，内部元素会垂直居中

同样的效果会应用给其中的所有子元素。

```css
.FlexWrapper {
    background-color: aquamarine;
    display: flex;
    height: 200px;
    width: 400px;
    align-items: center;
}
.FlexInner {
    background-color: aqua;
    display: flex;
    height: 100px;
    width: 200px;
}
```

```html
<div class="FlexWrapper">
        <div class="FlexInner">I am content in the inner Flexbox.</div>
        <div class="FlexInner">I am content in the inner Flexbox.</div>
        <div class="FlexInner">I am content in the inner Flexbox.</div>
    </div>
```

![1563442779009](images\1563442779009.png)

#### align-self

将某个元素按不同方式对齐。这个元素可以使用align-self属性决
定自己的对齐方式。

```css
.AlignSelf {
    align-self: flex-end;
}
```

```html
<div class="FlexWrapper">
        <div class="FlexInner">I am content in the inner Flexbox.</div>
        <div class="FlexInner AlignSelf">I am content in the inner Flexbox.</div>
        <div class="FlexInner">I am content in the inner Flexbox.</div>
    </div>
```

![1563443013625](images\1563443013625.png)

#### 交叉轴的对齐

> `flex-start`：把元素的对齐设置为`flex-start`，可以让元素从	`Flexbox`父元素的起始边开始。
>
> `flex-end`：把元素的对齐设置为`flex-end`，会沿`Flexbox`父元素的末尾对齐该元素。
>
> `center`：把元素放在`Flexbox`元素的中间。
>
> `baseline`：让`Flexbox`元素中的所有项沿基线对齐。
>
> `stretch`：让`Flexbox`中的所有项（没交叉轴）拉伸至与父元素一样大。

#### justify-content

控制沿`Flexbox`主轴对齐的属性是`justify-content`，它的属性值如下：

1. flex-start
2. flex-end
3. center
4. space-between

```css
.FlexWrapper {
    background-color: rgb(138, 87, 175);
    display: flex;
    justify-content: space-between;
    height: 200px;
    width: 100%;
}
.FlexInner {
    background-color: #34005B;
    display: flex;
    height: 100px;
    width: 25%;
    color: white;
}
```

![1563443502022](images\1563443502022.png)

justify-content可以告诉浏览器怎么处理其余空间。space-between会在子元素之间添加相同宽度的空白，而space-around则在它们两边各添加相同宽度的空白。

5. space-around

```
.FlexWrapper {
    background-color: rgb(138, 87, 175);
    display: flex;
    justify-content: space-around;
    height: 200px;
    width: 100%;
}
.FlexInner {
    background-color: #34005B;
    display: flex;
    height: 100px;
    width: 25%;
    color: white;
}
```

![1563443598337](images\1563443598337.png)

### flex伸缩性

flex实际上是三个属性合体的简写：flex-grow、flex-shrink和flex-basis

![1563443724468](images\1563443724468.png)

> flex-grow（传给flex的第一个值）是相对于其他伸缩项，当前伸缩项在空间允许的情况下可以伸展的量。
>
> flex-shrink是在空间不够的情况下，当前伸缩项相对于其他伸缩项可以收缩的量。
>
> flex-basis（传给flex的最后一个值）是伸缩项伸缩的基准值。

```css
/*在有空间的情况下可以伸展1部分，在空间不足时可以收缩1部分，而基准大小是内容的固有宽度*/
flex: 1 2 auto;
/*这个伸缩项既不伸也不缩，基准为50像素*/
flex: 0 0 50px;
/*会多占用两个可用空间，不收缩，基准为50%*/
flex: 2 0 50%;
```




```css
.FlexWrapper {
	background-color: indigo;
	display: flex;
	justify-content: space-around;
	height: 200px;
	width: 100%;
}

.FlexItems {
	border: 1px solid #ebebeb;
	background-color: #34005B;
	display: flex;
	height: 100px;
}

.FlexOne {
	flex: 1.5;
}

.FlexTwo,
.FlexThree {
	flex: 1;
}
```

```html
<div class="FlexWrapper">
		<div class="FlexItems FlexOne">I am content in the inner Flexbox 1.</div>
		<div class="FlexItems FlexTwo">I am content in the inner Flexbox 2.</div>
		<div class="FlexItems FlexThree">I am content in the inner Flexbox 3.</div>
	</div>
```

![1563442283369](images\1563442283369.png)

### 改变原始次序

在不修改原始`html`结构的基础上，改变`flexbox`容器中的子元素的显示顺序

```css
 .FlexWrapper{
            background-color: aliceblue;
            display: flex;
            flex-direction: column;
        }
        .FlexItems{
            display: flex;
            align-items: center;
            min-height: 6.25rem;
            padding: 1rem;
        }
        .FlexHeader {
            background-color: #105B63;
        }
        .FlexContent {
            background-color: #FFFAD5;
            order: -1;
        }
        .FlexSideOne {
             background-color: #FFD34E;
        }
        .FlexSideTwo {
            background-color: #DB9E36;
        }
        .FlexFooter {
            background-color: #BD4932;
        }
```

```html
<div class="FlexWrapper">
        <div class="FlexItems FlexHeader">I am content in the Header.</div>
        <div class="FlexItems FlexSideOne">I am content in the SideOne.</div>
        <div class="FlexItems FlexContent">I am content in the Content.</div>
        <div class="FlexItems FlexSideTwo">I am content in the SideTwo.</div>
        <div class="FlexItems FlexFooter">I am content in the Footer.</ div>
    </div>
```

这里的order属性可以在`Flexbox`中简单、明确地修改元素的次序。此处的-1表示要位于其他所有元素之前。

![1563502248810](images\1563502248810.png)